<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5" />
  <title>26ë…„ ê°€ì¡± ë§ˆì¸ë“œë§µ - ìœ¤í›„</title>
  <style>
    :root{
      --bg:#0b0f14;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#fb923c;
    }
    *{box-sizing:border-box}
    html, body { height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Segoe UI, Roboto, Arial, "Helvetica Neue", sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% 10%, rgba(251,146,60,.18), transparent 55%),
                  radial-gradient(1000px 600px at 80% 20%, rgba(56,189,248,.12), transparent 60%),
                  var(--bg);
      overflow:hidden;
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
      overscroll-behavior:none;
    }

    .topbar{
      position:fixed;
      left:16px; right:16px; top:14px;
      display:flex;
      gap:12px;
      align-items:center;
      z-index:5;
      pointer-events:auto;
    }
    .brand{
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(16,24,38,.72);
      backdrop-filter: blur(10px);
      border-radius:14px;
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width: 260px;
    }
    .brand h1{ font-size:14px; margin:0; font-weight:700; letter-spacing:-.2px; }
    .brand small{ color:rgba(148,163,184,.95); font-size:12px }

    .controls{
      flex:1;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,42,.92);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      font-size:12px;
    }

    .hint{
      position: fixed;
      left: 16px;
      bottom: 14px;
      z-index: 5;
      font-size: 12px;
      color: rgba(148,163,184,.95);
      background: rgba(16,24,38,.62);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      max-width: 560px;
      line-height: 1.4;
    }

    #viewport{ position:absolute; inset:0; padding-top: 64px; }
    svg{
      width:100%;
      height:100%;
      touch-action:none;
      -ms-touch-action:none;
      display:block;
    }

    @media (max-width: 720px){
      .brand{min-width:0}
      .hint{max-width: calc(100vw - 32px)}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <h1>ë§ˆì¸ë“œë§µ</h1>
      <small>ìœ¤í›„</small>
    </div>

    <div class="controls">
      <button class="btn" id="expandAll">í¼ì¹˜ê¸°</button>
      <button class="btn" id="collapseAll">ì ‘ê¸°</button>
      <button class="btn" id="resetView">ë¦¬ì…‹</button>
    </div>
  </div>

  <div id="viewport">
    <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <div class="hint">
    ğŸ“± í•œ ì†ê°€ë½ ë“œë˜ê·¸ë¡œ ì´ë™ Â· ë‘ ì†ê°€ë½ í•€ì¹˜ë¡œ ì¤Œ Â· ìƒë‹¨ ë²„íŠ¼ìœ¼ë¡œë§Œ ì „ì²´ ì ‘ê¸°/í¼ì¹˜ê¸°
  </div>

  <script>
    // -----------------------------
    // Data (ìœ¤í›„)
    // -----------------------------
    const data = {
      title: "ìœ¤í›„",
      note: "2026",
      icon: "ğŸ§’",
      children: [
        { title: "ê±´ê°•", icon: "ğŸ’ª", chips: ["ìš´ë™","ìŠµê´€"], children: [
          { title: "ë†êµ¬ë‹¤ë‹ˆê¸°", icon: "ğŸ€", children: [
            { title: "ì¹œêµ¬ë‘ ë†êµ¬ ë§ì´ í•´ë³´ê¸°", icon: "ğŸ¤" },
          ]},
          { title: "ê°„ì‹ì¤„ì´ê¸°", icon: "ğŸª" },
          { title: "ë‹¤ì´ì–´íŠ¸í•˜ê¸° (50kg ì´í•˜ë¡œ ë¹¼ê¸°)", icon: "âš–ï¸", chips: ["â‰¤ 50kg"] },
        ]},
        { title: "ëˆ", icon: "ğŸ’°", chips: ["ì €ì¶•","ê¸°ë¶€"], children: [
          { title: "ê¸°ë¶€í•˜ê¸° (1ë§Œì›)", icon: "ğŸ", chips: ["10,000ì›"] },
          { title: "40ë§Œì› ë‹¤ì‹œ ëª¨ìœ¼ê¸°", icon: "ğŸ¦", chips: ["400,000ì›"] },
        ]},
        { title: "ê³µë¶€", icon: "ğŸ“š", chips: ["ìŠµê´€","ì˜ì–´"], children: [
          { title: "ê¸€ì”¨ ì˜ì“°ê¸°", icon: "âœï¸", children: [
            { title: "ìˆ˜í•™ì‹ ì˜ì“°ê¸°", icon: "â—" },
            { title: "ê¸€ì”¨ ì˜ì“°ê¸°", icon: "ğŸ–Šï¸" },
          ]},
          { title: "ê³µë¶€ë¡œ ì—„ë§ˆì™€ ì‹¸ìš°ì§€ ì•Šê¸°", icon: "ğŸ•Šï¸" },
          { title: "ì˜ì–´", icon: "ğŸ‡ºğŸ‡¸", children: [
            { title: "ì˜ì–´ë‹¨ì–´ 100ì  ë§ì´ ë°›ê¸°", icon: "ğŸ’¯" },
            { title: "ì˜ì–´ ë ˆë²¨ì—…", icon: "ğŸ†™" },
          ]},
        ]},
        { title: "ë†€ê¸°", icon: "ğŸ§¸", chips: ["ì•½ì†","ìì œ"], children: [
          { title: "ì•½ì† ì˜ ì§€í‚¤ê¸°", icon: "â°", children: [
            { title: "ì—„ë§ˆë‘ ì•½ì†í•œ ì‹œê°„ ì§€í‚¤ê¸°", icon: "ğŸ“Œ" },
          ]},
          { title: "ê²Œì„ ì™¸ ë‹¤ë¥¸ ë†€ì´í•˜ê¸°", icon: "ğŸ²" },
          { title: "í•«ìŠ¤íŒŸ ì¼œì£¼ì§€ ì•Šê¸°", icon: "ğŸ“µ" },
        ]},
        { title: "ê°€ì¡±", icon: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦", chips: ["ê´€ê³„","ì‘ì›"], children: [
          { title: "ì—„ë§ˆ/ì•„ë¹ ë‘ ë‹¤íˆ¬ì§€ ì•Šê¸°", icon: "ğŸ¤" },
          { title: "í˜•ì´ë‘ ë‹¤íˆ¬ì§€ ì•Šê¸°", icon: "ğŸ«‚" },
          { title: "ì—¬í–‰ ì°¸ê¸°", icon: "ğŸ§³" },
          { title: "í˜• ì‘ì›í•´ì£¼ê¸°", icon: "ğŸ“£" },
          { title: "ì•„ë¹ ì˜í™”ê´€", icon: "ğŸ¬", children: [
            { title: "ì¬ë¯¸ìˆëŠ” ì˜í™”ì„ íƒ", icon: "ğŸ¿" },
            { title: "ê³¼ìë„ íŒ”ê¸°", icon: "ğŸ«" },
          ]},
        ]},
      ],
    };

    // -----------------------------
    // SVG helpers
    // -----------------------------
    const NS = "http://www.w3.org/2000/svg";
    function el(name, attrs = {}) {
      const n = document.createElementNS(NS, name);
      for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
      return n;
    }

    // -----------------------------
    // State
    // -----------------------------
    const svg = document.getElementById("svg");
    const isMobile = window.matchMedia('(pointer:coarse)').matches || window.matchMedia('(max-width: 560px)').matches;

    const expandAllBtn = document.getElementById("expandAll");
    const collapseAllBtn = document.getElementById("collapseAll");
    const resetViewBtn = document.getElementById("resetView");

    let selectedId = null;
    let view = { x: 0, y: 0, k: 1 };

    const NODE_W = 310;
    const NODE_H_BASE = 78;
    const CHIP_H = 18;
    const CHIP_PAD = 8;
    const R_STEP = isMobile ? 380 : 340;

    // -----------------------------
    // Tree & Layout
    // -----------------------------
    function uid() { return Math.random().toString(36).slice(2, 10); }

    function enrichTree(root, parent=null, depth=0, path="") {
      const id = uid();
      return {
        id,
        title: root.title,
        note: root.note || "",
        icon: root.icon || "â€¢",
        chips: root.chips || [],
        parentId: parent ? parent.id : null,
        depth,
        path: path ? `${path} â€º ${root.title}` : root.title,
        collapsed: root.collapsed || false,
        children: (root.children || []).map(ch => enrichTree(ch, { id }, depth+1, path ? `${path} â€º ${root.title}` : root.title)),
        x: 0, y: 0,
        branchIndex: 0,
      };
    }

    function flattenVisible(node, arr=[]) {
      arr.push(node);
      if (!node.collapsed && node.children) node.children.forEach(ch => flattenVisible(ch, arr));
      return arr;
    }

    function buildLinks(visibleNodes) {
      const byId = new Map(visibleNodes.map(n => [n.id, n]));
      const l = [];
      for (const n of visibleNodes) {
        if (n.parentId && byId.has(n.parentId)) l.push({ source: byId.get(n.parentId), target: n });
      }
      return l;
    }

    function countLeaves(node) {
      if (!node.children || node.children.length === 0) return 1;
      if (node.collapsed) return 1;
      return node.children.reduce((sum, ch) => sum + countLeaves(ch), 0);
    }

    function nodeHeight(n){
      const chips = (n.chips || []).length;
      const rows = chips ? Math.ceil(chips / 3) : 0;
      return NODE_H_BASE + rows * (CHIP_H + 6);
    }

    function layout(root) {
      const visible = flattenVisible(root, []);
      const topChildren = root.children || [];
      const leafCounts = topChildren.map(ch => countLeaves(ch));
      const totalLeaves = leafCounts.reduce((a,b)=>a+b, 0) || 1;

      let angleStart = -Math.PI * 0.90;
      const angleSpan = Math.PI * 1.80;

      const branchAngles = [];
      for (let i=0;i<topChildren.length;i++){
        const portion = leafCounts[i] / totalLeaves;
        const a0 = angleStart;
        const a1 = angleStart + angleSpan * portion;
        branchAngles.push({ a0, a1 });
        angleStart = a1;
      }

      root.x = 0; root.y = 0; root.branchIndex = -1;
      for (let i=0;i<topChildren.length;i++){
        placeBranch(topChildren[i], branchAngles[i].a0, branchAngles[i].a1, 1, i);
      }

      function placeBranch(node, a0, a1, depth, branchIndex){
        node.branchIndex = branchIndex;
        const mid = (a0 + a1) / 2;
        const r = depth * R_STEP;
        node.x = Math.cos(mid) * r;
        node.y = Math.sin(mid) * r;

        if (!node.children || node.children.length === 0 || node.collapsed) return;
        const leaves = node.children.map(ch => countLeaves(ch));
        const tot = leaves.reduce((a,b)=>a+b,0) || 1;
        let cur = a0;
        for (let j=0;j<node.children.length;j++){
          const span = (a1 - a0) * (leaves[j]/tot);
          placeBranch(node.children[j], cur, cur + span, depth+1, branchIndex);
          cur += span;
        }
      }

      const ITER = isMobile ? 26 : 22;
      const PADDING = isMobile ? 34 : 30;
      const CENTER_PULL = 0.018;

      for (let it = 0; it < ITER; it++) {
        const list = visible.filter(n => n.depth !== 0);
        for (let i = 0; i < list.length; i++) {
          for (let j = i + 1; j < list.length; j++) {
            const a = list[i], c = list[j];
            const ha = nodeHeight(a), hc = nodeHeight(c);
            const ra = Math.sqrt((NODE_W/2)**2 + (ha/2)**2) + PADDING;
            const rc = Math.sqrt((NODE_W/2)**2 + (hc/2)**2) + PADDING;
            const minDist = ra + rc;

            let dx = c.x - a.x;
            let dy = c.y - a.y;
            let d = Math.hypot(dx, dy);
            if (d < 0.0001) { dx = 0.01; dy = -0.01; d = Math.hypot(dx,dy); }

            if (d < minDist) {
              const push = (minDist - d) * 0.55;
              const ux = dx / d, uy = dy / d;
              a.x -= ux * push; a.y -= uy * push;
              c.x += ux * push; c.y += uy * push;
            }
          }
        }
        for (const n of visible) {
          if (n.depth === 0) continue;
          const rTarget = n.depth * R_STEP;
          const rNow = Math.hypot(n.x, n.y) || 1;
          const t = (rTarget - rNow) * CENTER_PULL;
          n.x += (n.x / rNow) * t;
          n.y += (n.y / rNow) * t;
        }
      }
      return visible;
    }

    // -----------------------------
    // Render
    // -----------------------------
    let tree = enrichTree(data);
    let nodes = [];
    let links = [];

    function setTransform(){
      const g = document.getElementById("gMain");
      if (g) g.setAttribute("transform", `translate(${view.x},${view.y}) scale(${view.k})`);
    }

    function render() {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      const g = el("g", { id:"gMain", transform:`translate(${view.x},${view.y}) scale(${view.k})` });
      svg.appendChild(g);

      nodes = layout(tree);
      links = buildLinks(nodes);

      for (const l of links) {
        const x1 = l.source.x, y1 = l.source.y;
        const x2 = l.target.x, y2 = l.target.y;
        const dx = (x2 - x1) * 0.35;
        const dy = (y2 - y1) * 0.35;
        g.appendChild(el("path", {
          d: `M ${x1} ${y1} C ${x1+dx} ${y1+dy}, ${x2-dx} ${y2-dy}, ${x2} ${y2}`,
          fill: "none",
          stroke: "rgba(148,163,184,.45)",
          "stroke-width": "2.2"
        }));
      }

      for (const n of nodes) {
        const h = nodeHeight(n);
        const ng = el("g", { transform:`translate(${n.x - NODE_W/2}, ${n.y - h/2})` });
        ng.style.cursor = "pointer";

        const isSelected = (n.id === selectedId);
        ng.appendChild(el("rect", {
          x:"0", y:"0", width:String(NODE_W), height:String(h),
          rx:"18", ry:"18",
          fill: "rgba(16,24,38,.92)",
          stroke: isSelected ? "rgba(251,146,60,.70)" : "rgba(255,255,255,.10)",
          "stroke-width": isSelected ? "2.3" : "1.2"
        }));

        ng.appendChild(el("rect", {
          x:"12", y:"12", width:"34", height:"34",
          rx:"12", ry:"12",
          fill:"rgba(251,146,60,.14)",
          stroke:"rgba(251,146,60,.35)",
          "stroke-width":"1.2"
        }));

        const iconText = el("text", {
          x:"29", y:"35",
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          fill:"#e5e7eb",
          "font-size":"16"
        });
        iconText.textContent = n.icon || "â€¢";
        iconText.style.pointerEvents = "none";
        ng.appendChild(iconText);

        const title = el("text", {
          x:"56", y:"26",
          fill:"#e5e7eb",
          "font-size":"14",
          "font-weight":"800"
        });
        title.textContent = n.title;
        title.style.pointerEvents = "none";
        ng.appendChild(title);

        const sub = el("text", {
          x:"56", y:"46",
          fill:"rgba(148,163,184,.95)",
          "font-size":"11"
        });
        sub.textContent = n.note ? n.note : (n.depth === 0 ? "2026" : n.path);
        sub.style.pointerEvents = "none";
        ng.appendChild(sub);

        const chips = n.chips || [];
        if (chips.length) {
          const perRow = 3;
          const chipW = Math.floor((NODE_W - 24 - (CHIP_PAD*(perRow-1))) / perRow);
          chips.forEach((c, i) => {
            const row = Math.floor(i / perRow);
            const col = i % perRow;
            const cx = 12 + col*(chipW + CHIP_PAD);
            const cy = 58 + row*(CHIP_H + 6);
            const accent = /â‰¤|kg|ì›|,|íšŒ|ì›”|ë²ˆ/.test(c);

            const chipRect = el("rect", {
              x:String(cx), y:String(cy),
              width:String(chipW), height:String(CHIP_H),
              rx:"999", ry:"999",
              fill: accent ? "rgba(251,146,60,.12)" : "rgba(31,41,55,.72)",
              stroke: accent ? "rgba(251,146,60,.35)" : "rgba(255,255,255,.10)",
              "stroke-width":"1"
            });
            chipRect.style.pointerEvents = "none";
            ng.appendChild(chipRect);

            const chipText = el("text", {
              x:String(cx + chipW/2),
              y:String(cy + CHIP_H/2 + 0.5),
              "text-anchor":"middle",
              "dominant-baseline":"middle",
              fill:"#e5e7eb",
              "font-size":"10"
            });
            chipText.textContent = c;
            chipText.style.pointerEvents = "none";
            ng.appendChild(chipText);
          });
        }

        ng.addEventListener("click", () => { selectedId = n.id; render(); });
        g.appendChild(ng);
      }
    }

    // -----------------------------
    // Expand / Collapse
    // -----------------------------
    function walk(node, fn){
      fn(node);
      (node.children || []).forEach(ch => walk(ch, fn));
    }
    function collapseAll(){
      walk(tree, n => { if (n.depth>0) n.collapsed = true; });
      tree.collapsed = false;
      render();
    }
    function expandAll(){
      walk(tree, n => { n.collapsed = false; });
      render();
    }

    // -----------------------------
    // Pan / Zoom (father ì½”ë“œ ì°¸ì¡°: ëª¨ë°”ì¼ ì´ë™ + í•€ì¹˜ì¤Œ)
    // -----------------------------
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    svg.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = svg.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const scaleFactor = Math.exp(-e.deltaY * 0.0012);
      const k0 = view.k;
      const k1 = clamp(k0 * scaleFactor, 0.35, 2.6);
      view.x = cx - (cx - view.x) * (k1 / k0);
      view.y = cy - (cy - view.y) * (k1 / k0);
      view.k = k1;
      setTransform();
    }, { passive:false });

    const activePtrs = new Map();
    let panStart = null;
    let pinchState = null;

    function svgPointFromClient(clientX, clientY){
      const rect = svg.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }
    function dist(a,b){
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    svg.addEventListener("pointerdown", (e) => {
      try { svg.setPointerCapture(e.pointerId); } catch {}
      activePtrs.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePtrs.size === 1) {
        panStart = { x: e.clientX, y: e.clientY, vx: view.x, vy: view.y };
        pinchState = null;
      } else if (activePtrs.size === 2) {
        const pts = Array.from(activePtrs.values());
        const p0 = svgPointFromClient(pts[0].x, pts[0].y);
        const p1 = svgPointFromClient(pts[1].x, pts[1].y);
        pinchState = { k0: view.k, x0: view.x, y0: view.y, dist0: dist(p0,p1) };
        panStart = null;
      }
      e.preventDefault();
    }, { passive:false });

    svg.addEventListener("pointermove", (e) => {
      if (!activePtrs.has(e.pointerId)) return;
      activePtrs.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePtrs.size === 1 && panStart) {
        view.x = panStart.vx + (e.clientX - panStart.x);
        view.y = panStart.vy + (e.clientY - panStart.y);
        setTransform();
      } else if (activePtrs.size === 2 && pinchState) {
        const pts = Array.from(activePtrs.values());
        const p0 = svgPointFromClient(pts[0].x, pts[0].y);
        const p1 = svgPointFromClient(pts[1].x, pts[1].y);
        const d1 = dist(p0,p1);

        const k1 = clamp(pinchState.k0 * (d1 / (pinchState.dist0 || 1)), 0.35, 2.6);
        const mid = { x: (p0.x+p1.x)/2, y: (p0.y+p1.y)/2 };
        const k0 = pinchState.k0;

        view.x = mid.x - (mid.x - pinchState.x0) * (k1 / k0);
        view.y = mid.y - (mid.y - pinchState.y0) * (k1 / k0);
        view.k = k1;
        setTransform();
      }
      e.preventDefault();
    }, { passive:false });

    function endPointer(e){
      activePtrs.delete(e.pointerId);
      if (activePtrs.size === 0) { panStart = null; pinchState = null; }
      if (activePtrs.size === 1) {
        const remaining = Array.from(activePtrs.values())[0];
        panStart = { x: remaining.x, y: remaining.y, vx: view.x, vy: view.y };
        pinchState = null;
      }
      e.preventDefault();
    }
    svg.addEventListener("pointerup", endPointer, { passive:false });
    svg.addEventListener("pointercancel", endPointer, { passive:false });

    // Touch fallback (iOS ì•ˆì „ë§)
    let tPan = null, tPinch = null;
    function getTouchMid(t1, t2){
      const rect = svg.getBoundingClientRect();
      return { x: ((t1.clientX+t2.clientX)/2)-rect.left, y: ((t1.clientY+t2.clientY)/2)-rect.top };
    }
    function getTouchDist(t1, t2){
      const rect = svg.getBoundingClientRect();
      const p0 = { x: t1.clientX-rect.left, y: t1.clientY-rect.top };
      const p1 = { x: t2.clientX-rect.left, y: t2.clientY-rect.top };
      return Math.hypot(p0.x-p1.x, p0.y-p1.y);
    }
    svg.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        tPan = { x: t.clientX, y: t.clientY, vx: view.x, vy: view.y };
        tPinch = null;
      } else if (e.touches.length === 2) {
        const d0 = getTouchDist(e.touches[0], e.touches[1]);
        tPinch = { k0: view.k, x0: view.x, y0: view.y, d0 };
        tPan = null;
      }
      e.preventDefault();
    }, { passive:false });

    svg.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1 && tPan) {
        const t = e.touches[0];
        view.x = tPan.vx + (t.clientX - tPan.x);
        view.y = tPan.vy + (t.clientY - tPan.y);
        setTransform();
      } else if (e.touches.length === 2 && tPinch) {
        const d1 = getTouchDist(e.touches[0], e.touches[1]);
        const k1 = clamp(tPinch.k0 * (d1 / (tPinch.d0 || 1)), 0.35, 2.6);

        const mid = getTouchMid(e.touches[0], e.touches[1]);
        const k0 = tPinch.k0;

        view.x = mid.x - (mid.x - tPinch.x0) * (k1 / k0);
        view.y = mid.y - (mid.y - tPinch.y0) * (k1 / k0);
        view.k = k1;
        setTransform();
      }
      e.preventDefault();
    }, { passive:false });

    svg.addEventListener("touchend", (e) => {
      if (e.touches.length === 0) { tPan = null; tPinch = null; }
      if (e.touches.length === 1) {
        const t = e.touches[0];
        tPan = { x: t.clientX, y: t.clientY, vx: view.x, vy: view.y };
        tPinch = null;
      }
    }, { passive:false });

    // -----------------------------
    // init
    // -----------------------------
    function resetView(){
      const rect = svg.getBoundingClientRect();
      view.k = isMobile ? 0.72 : 1;
      view.x = rect.width/2;
      view.y = rect.height/2 + 40;
      setTransform();
    }

    window.addEventListener("resize", () => { resetView(); render(); });
    expandAllBtn.addEventListener("click", expandAll);
    collapseAllBtn.addEventListener("click", collapseAll);
    resetViewBtn.addEventListener("click", () => { resetView(); render(); });

    resetView();
    render();
  </script>
</body>
</html>
