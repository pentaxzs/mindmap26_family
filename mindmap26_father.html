<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5" />
  <title>26ë…„ ê°€ì¡± ë§ˆì¸ë“œë§µ - ì•„ë¹ (ê¹€ê¸°ì„±)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#fb923c;
    }
    *{box-sizing:border-box}
    html, body { height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Segoe UI, Roboto, Arial, "Helvetica Neue", sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% 10%, rgba(251,146,60,.18), transparent 55%),
                  radial-gradient(1000px 600px at 80% 20%, rgba(56,189,248,.12), transparent 60%),
                  var(--bg);
      overflow:hidden;
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
      overscroll-behavior:none;
    }

    .topbar{
      position:fixed;
      left:16px; right:16px; top:14px;
      display:flex;
      gap:12px;
      align-items:center;
      z-index:5;
      pointer-events:auto;
    }
    .brand{
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(16,24,38,.72);
      backdrop-filter: blur(10px);
      border-radius:14px;
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width: 260px;
    }
    .brand h1{ font-size:14px; margin:0; font-weight:700; letter-spacing:-.2px; }
    .brand small{ color:rgba(148,163,184,.95); font-size:12px }

    .controls{
      flex:1;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }
    .pill{
      display:flex; gap:8px; align-items:center;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(16,24,38,.72);
      backdrop-filter: blur(10px);
    }
    .pill label{font-size:12px; color:rgba(148,163,184,.95)}
    .pill input{
      width:220px;
      padding:8px 10px;
      background: rgba(15,23,42,.9);
      color: var(--text);
      border:1px solid rgba(255,255,255,.10);
      border-radius:10px;
      outline:none;
      -webkit-user-select:text;
      user-select:text;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,42,.92);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      font-size:12px;
    }

    .hint{
      position: fixed;
      left: 16px;
      bottom: 64px; /* ì§„í–‰ë¥  ë°”ì™€ ê²¹ì¹˜ì§€ ì•Šê²Œ */
      z-index: 5;
      font-size: 12px;
      color: rgba(148,163,184,.95);
      background: rgba(16,24,38,.62);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      max-width: 560px;
      line-height: 1.4;
    }

    .progressbar{
      position: fixed;
      left: 16px;
      right: 16px;
      bottom: 14px;
      z-index: 5;
      display:flex;
      align-items:center;
      gap:12px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(16,24,38,.72);
      border: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
    }
    .progressbar .label{
      font-size: 12px;
      color: rgba(148,163,184,.95);
      white-space: nowrap;
    }
    .progressbar .track{
      position: relative;
      flex:1;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
    }
    .progressbar .fill{
      position:absolute;
      inset:0;
      width:0%;
      background: rgba(251,146,60,.75);
    }
    .progressbar .meta{
      font-size: 12px;
      color: rgba(229,231,235,.95);
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
    }

    #viewport{ position:absolute; inset:0; padding-top: 64px; }
    svg{
      width:100%;
      height:100%;
      touch-action:none;
      -ms-touch-action:none;
      display:block;
    }

    @media (max-width: 720px){
      .brand{min-width:0}
      .pill input{width:140px}
      .hint{max-width: calc(100vw - 32px)}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <h1>ë§ˆì¸ë“œë§µ</h1>
      <small>ì•„ë¹ </small>
    </div>

    <div class="controls">
      <!-- ê²€ìƒ‰ UI ì œê±° -->
      <button class="btn" id="expandAll">í¼ì¹˜ê¸°</button>
      <button class="btn" id="collapseAll">ì ‘ê¸°</button>
      <button class="btn" id="resetView">ë¦¬ì…‹</button>
    </div>
  </div>

  <div id="viewport">
    <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <div class="hint">
    ğŸ“± í•œ ì†ê°€ë½ ë“œë˜ê·¸ë¡œ ì´ë™ Â· ë‘ ì†ê°€ë½ í•€ì¹˜ë¡œ ì¤Œ Â· ìƒë‹¨ ë²„íŠ¼ìœ¼ë¡œ ì „ì²´ ì ‘ê¸°/í¼ì¹˜ê¸°
  </div>

  <div class="progressbar" id="progressBar" aria-live="polite">
    <div class="label">ì§„í–‰ë¥ </div>
    <div class="track" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
      <div class="fill" id="progressFill"></div>
    </div>
    <div class="meta" id="progressMeta">0% (0/0)</div>
  </div>

  <script>
    // -----------------------------
    // Data (ì•„ë¹  ë§ˆì¸ë“œë§µ)
    // -----------------------------
    const data = {
      title: "ì•„ë¹ (ê¹€ê¸°ì„±)",
      note: "2026",
      icon: "ğŸ‘¨",
      children: [
        {
          title: "ê±´ê°•",
          icon: "ğŸ’ª",
          chips: ["ë£¨í‹´", "ìš´ë™"],
          children: [
            { title: "ìŠ¤íŠ¸ë ˆì¹­ (í•˜ë£¨ 10~15ë¶„)", icon: "ğŸ§˜", chips: ["10~15ë¶„/ì¼"] },
            { title: "ì•„ì¹¨ ëŸ¬ë‹ (2km)", icon: "ğŸƒ", chips: ["2km"] },
            { title: "í—¬ìŠ¤ì¥ (ì¼ì£¼ 2íšŒ)", icon: "ğŸ‹ï¸", chips: ["ì£¼2íšŒ"] },
            { title: "ê³¨í”„ (ì¼ì£¼ 2íšŒ)", icon: "â›³", chips: ["ì£¼2íšŒ"] },
          ],
        },
        {
          title: "ê°€ì¡±",
          icon: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦",
          chips: ["ê¸°ì–µ", "í•¨ê»˜"],
          children: [
            { title: "ì•„ë¹ ì˜í™”ê´€ (ê¸°ì–µë‚¨ëŠ” ì˜í™” ê³ ë¥´ê¸°)", icon: "ğŸ¬" },
            { title: "ë§ˆë¼í†¤ (5km w.ìœ¤í›„)", icon: "ğŸ", chips: ["5km"] },
            {
              title: "ì—¬í–‰ (êµ­ë‚´ ì—¬í–‰ ìœ„ì£¼ë¡œ ë‹¤ë‹ˆê¸°)",
              icon: "ğŸ§³",
              chips: ["êµ­ë‚´"],
              children: [
                { title: "ë¶€ì—¬/ì›ì£¼/ì†ì´ˆ", icon: "ğŸ—ºï¸" },
                { title: "ì œì£¼ë„", icon: "ğŸï¸" },
                { title: "êµ­ë‚´ì—¬í–‰ 2íšŒ (ë´„ & ê°€ì„)", icon: "ğŸ‚", chips: ["ì—°2íšŒ"] },
              ],
            },
          ],
        },
        {
          title: "íšŒì‚¬",
          icon: "ğŸ¢",
          chips: ["ì„±ê³¼", "ì¡°ì§"],
          children: [
            { title: "25ë…„ë³´ë‹¤ ë‚˜ì€ 26ë…„", icon: "ğŸ“ˆ" },
            { title: "ìƒˆë¡œìš´ ì„œë¹„ìŠ¤ êµ¬ìƒ ë° ë¦´ë¦¬ì¦ˆ", icon: "ğŸš€" },
            { title: "ì¡°ì§/ì‚¬ëŒ/ëª©í‘œ", icon: "ğŸ§­" },
          ],
        },
        {
          title: "ê³µë¶€",
          icon: "ğŸ“š",
          chips: ["ì¼ë³¸ì–´", "ì˜ì–´"],
          children: [
            {
              title: "ì¼ë³¸ì–´",
              icon: "ğŸ‡¯ğŸ‡µ",
              children: [
                { title: "ì±… ì½ê¸°(ì†Œì„¤/ë¼í“¨íƒ€/ë„ë¼ì—ëª½)", icon: "ğŸ“–" },
                { title: "EBSìˆ˜ì—…ë“£ê¸°", icon: "ğŸ§" },
                { title: "1:1 ìˆ˜ì—… ì—´ì‹¬íˆ", icon: "ğŸ‘¨â€ğŸ«" },
                { title: "ë¼í“¨íƒ€ 3ë²ˆ ì´ìƒ ë³´ê¸°", icon: "ğŸï¸", chips: ["3+íšŒ"] },
                { title: "ë¯¸ì¹œë§›ì§‘ ë³´ê¸°", icon: "ğŸœ" },
              ],
            },
            {
              title: "ì˜ì–´",
              icon: "ğŸ‡ºğŸ‡¸",
              children: [
                { title: "ì˜ì–´íšŒí™”w.Mayla", icon: "ğŸ—£ï¸" },
                { title: "ì•Œë¼ë”˜ 3ë²ˆ ì´ìƒ ë³´ê¸°", icon: "ğŸ§", chips: ["3+íšŒ"] },
              ],
            },
          ],
        },
        {
          title: "ë„¥ìŠ¤íŠ¸",
          icon: "ğŸ§ª",
          chips: ["ì°½ì‘", "ì‹¤í—˜"],
          children: [
            { title: "ë¸ŒëŸ°ì¹˜ ê¸€ì“°ê¸° (1íšŒ/ì›”)", icon: "âœï¸", chips: ["ì›”1íšŒ"] },
            { title: "ê´‘ê³ ì„œë¹„ìŠ¤ ë§Œë“¤ê¸° (1íšŒ/2ê°œì›”)", icon: "ğŸ“£", chips: ["2ê°œì›”1íšŒ"] },
            { title: "AI ê°€ì´ë“œ ë§Œë“¤ê¸° (1íšŒ/ì›”)", icon: "ğŸ¤–", chips: ["ì›”1íšŒ"] },
          ],
        },
        {
          title: "ì¬í…Œí¬",
          icon: "ğŸ’°",
          chips: ["íˆ¬ì"],
          children: [
            { title: "ë°°ë‹¹ì£¼ ì¤‘ì‹¬ìœ¼ë¡œ ë¯¸ì¥íˆ¬ì", icon: "ğŸ‡ºğŸ‡¸" },
            { title: "ê°€ì¹˜ì£¼/ë‹¨íƒ€ êµ­ì¥íˆ¬ì", icon: "ğŸ‡°ğŸ‡·" },
          ],
        },
      ],
    };

    // -----------------------------
    // SVG helpers
    // -----------------------------
    const NS = "http://www.w3.org/2000/svg";
    function el(name, attrs = {}) {
      const n = document.createElementNS(NS, name);
      for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
      return n;
    }

    // -----------------------------
    // State
    // -----------------------------
    const svg = document.getElementById("svg");
    const isMobile = window.matchMedia('(pointer:coarse)').matches || window.matchMedia('(max-width: 560px)').matches;

    // ê²€ìƒ‰ ì…ë ¥(q) ê´€ë ¨ ì½”ë“œ ì œê±°

    const expandAllBtn = document.getElementById("expandAll");
    const collapseAllBtn = document.getElementById("collapseAll");
    const resetViewBtn = document.getElementById("resetView");

    const progressFill = document.getElementById("progressFill");
    const progressMeta = document.getElementById("progressMeta");
    const progressTrack = document.querySelector("#progressBar .track");

    let selectedId = null;
    // ê²€ìƒ‰ í•˜ì´ë¼ì´íŠ¸ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•Šì§€ë§Œ, ë Œë” ë¡œì§ì„ ê±´ë“œë¦¬ì§€ ì•Šê¸° ìœ„í•´ ë¹ˆ Set ìœ ì§€
    let highlightIds = new Set();

    let view = { x: 0, y: 0, k: 1 };

    // ë…¸ë“œ í¬ê¸°(ìœ¤í›„ì™€ ë™ì¼ ê³„ì—´)
    const NODE_W = 310;
    const NODE_H_BASE = 78;
    const CHIP_H = 18;
    const CHIP_PAD = 8;

    // ê²¹ì¹¨ ì™„í™” ë°˜ê²½
    const R_STEP = isMobile ? 380 : 340;

    // -----------------------------
    // ì²´í¬ë°•ìŠ¤ ìƒíƒœ (localStorage)
    // -----------------------------
    const STORAGE_KEY = "mindmap26_father_checks_v1";
    function loadChecks(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        const obj = raw ? JSON.parse(raw) : {};
        return new Map(Object.entries(obj).map(([k,v]) => [k, !!v]));
      }catch{
        return new Map();
      }
    }
    function saveChecks(map){
      try{
        const obj = Object.fromEntries(map.entries());
        localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
      }catch{}
    }
    const checks = loadChecks();

    function isChecked(key){ return !!checks.get(key); }
    function setChecked(key, val){
      checks.set(key, !!val);
      saveChecks(checks);
      updateProgress();
    }
    function toggleChecked(key){
      setChecked(key, !isChecked(key));
      render();
    }

    // -----------------------------
    // Tree & Layout
    // -----------------------------
    function uid() { return Math.random().toString(36).slice(2, 10); }

    function enrichTree(root, parent=null, depth=0, path="") {
      const id = uid();
      const nextPath = path ? `${path} â€º ${root.title}` : root.title;
      return {
        id,
        key: nextPath,               // âœ… êµ¬ì¡° ê¸°ë°˜ ê³ ì • í‚¤(ì§„í–‰ë¥ /ì €ì¥ìš©)
        title: root.title,
        note: root.note || "",
        icon: root.icon || "â€¢",
        chips: root.chips || [],
        parentId: parent ? parent.id : null,
        depth,
        path: nextPath,
        collapsed: root.collapsed || false,
        children: (root.children || []).map(ch => enrichTree(ch, { id }, depth+1, nextPath)),
        x: 0, y: 0,
        branchIndex: 0,
      };
    }

    function flattenVisible(node, arr=[]) {
      arr.push(node);
      if (!node.collapsed && node.children) node.children.forEach(ch => flattenVisible(ch, arr));
      return arr;
    }

    function walk(node, fn){
      fn(node);
      (node.children || []).forEach(ch => walk(ch, fn));
    }

    function buildLinks(visibleNodes) {
      const byId = new Map(visibleNodes.map(n => [n.id, n]));
      const l = [];
      for (const n of visibleNodes) {
        if (n.parentId && byId.has(n.parentId)) l.push({ source: byId.get(n.parentId), target: n });
      }
      return l;
    }

    function countLeaves(node) {
      if (!node.children || node.children.length === 0) return 1;
      if (node.collapsed) return 1;
      return node.children.reduce((sum, ch) => sum + countLeaves(ch), 0);
    }

    function nodeHeight(n){
      const chips = (n.chips || []).length;
      const rows = chips ? Math.ceil(chips / 3) : 0;
      return NODE_H_BASE + rows * (CHIP_H + 6);
    }

    function layout(root) {
      const visible = flattenVisible(root, []);

      const topChildren = root.children || [];
      const leafCounts = topChildren.map(ch => countLeaves(ch));
      const totalLeaves = leafCounts.reduce((a,b)=>a+b, 0) || 1;

      let angleStart = -Math.PI * 0.90;
      const angleSpan = Math.PI * 1.80;

      const branchAngles = [];
      for (let i=0;i<topChildren.length;i++){
        const portion = leafCounts[i] / totalLeaves;
        const a0 = angleStart;
        const a1 = angleStart + angleSpan * portion;
        branchAngles.push({ a0, a1 });
        angleStart = a1;
      }

      root.x = 0; root.y = 0;
      root.branchIndex = -1;

      for (let i=0;i<topChildren.length;i++){
        placeBranch(topChildren[i], branchAngles[i].a0, branchAngles[i].a1, 1, i);
      }

      function placeBranch(node, a0, a1, depth, branchIndex){
        node.branchIndex = branchIndex;
        const mid = (a0 + a1) / 2;
        const r = depth * R_STEP;
        node.x = Math.cos(mid) * r;
        node.y = Math.sin(mid) * r;

        if (!node.children || node.children.length === 0 || node.collapsed) return;

        const leaves = node.children.map(ch => countLeaves(ch));
        const tot = leaves.reduce((a,b)=>a+b,0) || 1;
        let cur = a0;
        for (let j=0;j<node.children.length;j++){
          const span = (a1 - a0) * (leaves[j]/tot);
          placeBranch(node.children[j], cur, cur + span, depth+1, branchIndex);
          cur += span;
        }
      }

      // ì „ì—­ ë¦¬í„ìŠ¤(ê²¹ì¹¨ ì™„í™”)
      const ITER = isMobile ? 26 : 22;
      const PADDING = isMobile ? 34 : 30;
      const CENTER_PULL = 0.018;

      for (let it = 0; it < ITER; it++) {
        const list = visible.filter(n => n.depth !== 0);
        for (let i = 0; i < list.length; i++) {
          for (let j = i + 1; j < list.length; j++) {
            const a = list[i], c = list[j];

            const ha = nodeHeight(a), hc = nodeHeight(c);
            const ra = Math.sqrt((NODE_W/2)**2 + (ha/2)**2) + PADDING;
            const rc = Math.sqrt((NODE_W/2)**2 + (hc/2)**2) + PADDING;
            const minDist = ra + rc;

            let dx = c.x - a.x;
            let dy = c.y - a.y;
            let d = Math.hypot(dx, dy);
            if (d < 0.0001) { dx = 0.01; dy = -0.01; d = Math.hypot(dx,dy); }

            if (d < minDist) {
              const push = (minDist - d) * 0.55;
              const ux = dx / d, uy = dy / d;
              a.x -= ux * push; a.y -= uy * push;
              c.x += ux * push; c.y += uy * push;
            }
          }
        }

        for (const n of visible) {
          if (n.depth === 0) continue;
          const rTarget = n.depth * R_STEP;
          const rNow = Math.hypot(n.x, n.y) || 1;
          const t = (rTarget - rNow) * CENTER_PULL;
          n.x += (n.x / rNow) * t;
          n.y += (n.y / rNow) * t;
        }
      }

      return visible;
    }

    // -----------------------------
    // Progress UI
    // -----------------------------
    function computeProgress(){
      let total = 0, done = 0;
      walk(tree, (n) => {
        if (n.depth === 0) return; // ë£¨íŠ¸ ì œì™¸
        total += 1;
        if (isChecked(n.key)) done += 1;
      });
      const pct = total ? Math.round((done / total) * 100) : 0;
      return { total, done, pct };
    }

    function updateProgress(){
      const { total, done, pct } = computeProgress();
      progressFill.style.width = pct + "%";
      progressMeta.textContent = `${pct}% (${done}/${total})`;
      if (progressTrack) progressTrack.setAttribute("aria-valuenow", String(pct));
    }

    // -----------------------------
    // Render
    // -----------------------------
    let tree = enrichTree(data);
    let nodes = [];
    let links = [];

    function setTransform(){
      const g = document.getElementById("gMain");
      if (g) g.setAttribute("transform", `translate(${view.x},${view.y}) scale(${view.k})`);
    }

    function render() {
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const g = el("g", { id:"gMain", transform:`translate(${view.x},${view.y}) scale(${view.k})` });
      svg.appendChild(g);

      nodes = layout(tree);
      links = buildLinks(nodes);

      // links
      for (const l of links) {
        const x1 = l.source.x, y1 = l.source.y;
        const x2 = l.target.x, y2 = l.target.y;
        const dx = (x2 - x1) * 0.35;
        const dy = (y2 - y1) * 0.35;

        g.appendChild(el("path", {
          d: `M ${x1} ${y1} C ${x1+dx} ${y1+dy}, ${x2-dx} ${y2-dy}, ${x2} ${y2}`,
          fill: "none",
          stroke: "rgba(148,163,184,.45)",
          "stroke-width": "2.2"
        }));
      }

      // nodes
      for (const n of nodes) {
        const h = nodeHeight(n);
        const ng = el("g", { transform:`translate(${n.x - NODE_W/2}, ${n.y - h/2})` });
        ng.style.cursor = "pointer";

        const isSelected = (n.id === selectedId);
        const isHighlight = highlightIds.has(n.id); // ê²€ìƒ‰ ê¸°ëŠ¥ ì œê±°ë¡œ í•­ìƒ false
        const checked = isChecked(n.key);

        ng.appendChild(el("rect", {
          x:"0", y:"0", width:String(NODE_W), height:String(h),
          rx:"18", ry:"18",
          fill: "rgba(16,24,38,.92)",
          stroke: isSelected ? "rgba(251,146,60,.70)" : (isHighlight ? "rgba(56,189,248,.80)" : "rgba(255,255,255,.10)"),
          "stroke-width": isSelected || isHighlight ? "2.3" : "1.2"
        }));

        ng.appendChild(el("rect", {
          x:"12", y:"12", width:"34", height:"34",
          rx:"12", ry:"12",
          fill:"rgba(251,146,60,.14)",
          stroke:"rgba(251,146,60,.35)",
          "stroke-width":"1.2"
        }));

        const iconText = el("text", {
          x:"29", y:"35",
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          fill:"#e5e7eb",
          "font-size":"16"
        });
        iconText.textContent = n.icon || "â€¢";
        iconText.style.pointerEvents = "none";
        ng.appendChild(iconText);

        const title = el("text", {
          x:"56", y:"26",
          fill:"#e5e7eb",
          "font-size":"14",
          "font-weight":"800"
        });
        title.textContent = n.title;
        title.style.pointerEvents = "none";
        ng.appendChild(title);

        const sub = el("text", {
          x:"56", y:"46",
          fill:"rgba(148,163,184,.95)",
          "font-size":"11"
        });
        sub.textContent = n.note ? n.note : (n.depth === 0 ? "2026" : n.path);
        sub.style.pointerEvents = "none";
        ng.appendChild(sub);

        // âœ… ì²´í¬ë°•ìŠ¤ (ìš°ìƒë‹¨)
        // (ë£¨íŠ¸ë„ ì¹´ë“œë¡œ ë³´ì´ì§€ë§Œ, ë£¨íŠ¸ëŠ” ì²´í¬ ëŒ€ìƒ ì œì™¸)
        if (n.depth > 0) {
          const cbX = NODE_W - 40;
          const cbY = 16;
          const cbS = 18;

          const cb = el("rect", {
            x: String(cbX),
            y: String(cbY),
            width: String(cbS),
            height: String(cbS),
            rx: "5",
            ry: "5",
            fill: checked ? "rgba(251,146,60,.26)" : "rgba(15,23,42,.92)",
            stroke: checked ? "rgba(251,146,60,.70)" : "rgba(255,255,255,.18)",
            "stroke-width": "1.4"
          });
          cb.style.pointerEvents = "auto";
          cb.style.cursor = "pointer";

          const tick = el("text", {
            x: String(cbX + cbS/2),
            y: String(cbY + cbS/2 + 0.5),
            "text-anchor":"middle",
            "dominant-baseline":"middle",
            fill: checked ? "rgba(251,146,60,.95)" : "rgba(148,163,184,.25)",
            "font-size":"14",
            "font-weight":"900"
          });
          tick.textContent = "âœ“";
          tick.style.pointerEvents = "auto";
          tick.style.cursor = "pointer";

          const toggle = (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleChecked(n.key);
          };

          // âœ… pan/zoom í¬ì¸í„° ìº¡ì²˜ë³´ë‹¤ ë¨¼ì € ì´ë²¤íŠ¸ë¥¼ "ë¨¹ì–´ì„œ" ì²´í¬ê°€ ì•ˆ ë˜ëŠ” ë¬¸ì œ ë°©ì§€ (íŠ¹íˆ iOS)
          const swallow = (e) => { e.preventDefault(); e.stopPropagation(); };

          cb.addEventListener("pointerdown", swallow);
          tick.addEventListener("pointerdown", swallow);
          cb.addEventListener("touchstart", swallow, { passive:false });
          tick.addEventListener("touchstart", swallow, { passive:false });

          cb.addEventListener("pointerup", toggle);
          tick.addEventListener("pointerup", toggle);
          cb.addEventListener("click", toggle);
          tick.addEventListener("click", toggle);

          ng.appendChild(cb);
          ng.appendChild(tick);
        }

        // chips
        const chips = n.chips || [];
        if (chips.length) {
          const perRow = 3;
          const chipW = Math.floor((NODE_W - 24 - (CHIP_PAD*(perRow-1))) / perRow);

          chips.forEach((c, i) => {
            const row = Math.floor(i / perRow);
            const col = i % perRow;
            const cx = 12 + col*(chipW + CHIP_PAD);
            const cy = 58 + row*(CHIP_H + 6);
            const accent = /â‰¤|kg|ì›|,|íšŒ|ì›”|ë²ˆ|km|ë¶„|ì£¼/i.test(c);

            const chipRect = el("rect", {
              x:String(cx), y:String(cy),
              width:String(chipW), height:String(CHIP_H),
              rx:"999", ry:"999",
              fill: accent ? "rgba(251,146,60,.12)" : "rgba(31,41,55,.72)",
              stroke: accent ? "rgba(251,146,60,.35)" : "rgba(255,255,255,.10)",
              "stroke-width":"1"
            });
            chipRect.style.pointerEvents = "none";
            ng.appendChild(chipRect);

            const chipText = el("text", {
              x:String(cx + chipW/2),
              y:String(cy + CHIP_H/2 + 0.5),
              "text-anchor":"middle",
              "dominant-baseline":"middle",
              fill:"#e5e7eb",
              "font-size":"10"
            });
            chipText.textContent = c;
            chipText.style.pointerEvents = "none";
            ng.appendChild(chipText);
          });
        }

        // ì¹´ë“œ ë‚´ë¶€ ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼ì€ ì œê±°(ìš”ì²­ì‚¬í•­)
        ng.addEventListener("click", () => { selectedId = n.id; render(); });

        g.appendChild(ng);
      }

      updateProgress();
    }

    // -----------------------------
    // expand-collapse
    // -----------------------------
    function collapseAll(){
      walk(tree, n => { if (n.depth>0) n.collapsed = true; });
      tree.collapsed = false;
      render();
    }
    function expandAll(){
      walk(tree, n => { n.collapsed = false; });
      render();
    }

    // -----------------------------
    // Pan / Zoom (ìœ¤í›„ì™€ ë™ì¼)
    // -----------------------------
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    svg.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = svg.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;

      const scaleFactor = Math.exp(-e.deltaY * 0.0012);
      const k0 = view.k;
      const k1 = clamp(k0 * scaleFactor, 0.35, 2.6);

      view.x = cx - (cx - view.x) * (k1 / k0);
      view.y = cy - (cy - view.y) * (k1 / k0);
      view.k = k1;
      setTransform();
    }, { passive:false });

    const activePtrs = new Map();
    let panStart = null;
    let pinchState = null;

    function svgPointFromClient(clientX, clientY){
      const rect = svg.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }
    function dist(a,b){
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    svg.addEventListener("pointerdown", (e) => {
      try { svg.setPointerCapture(e.pointerId); } catch {}
      activePtrs.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePtrs.size === 1) {
        panStart = { x: e.clientX, y: e.clientY, vx: view.x, vy: view.y };
        pinchState = null;
      } else if (activePtrs.size === 2) {
        const pts = Array.from(activePtrs.values());
        const p0 = svgPointFromClient(pts[0].x, pts[0].y);
        const p1 = svgPointFromClient(pts[1].x, pts[1].y);
        pinchState = { k0: view.k, x0: view.x, y0: view.y, dist0: dist(p0,p1) };
        panStart = null;
      }
      e.preventDefault();
    }, { passive:false });

    svg.addEventListener("pointermove", (e) => {
      if (!activePtrs.has(e.pointerId)) return;
      activePtrs.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePtrs.size === 1 && panStart) {
        view.x = panStart.vx + (e.clientX - panStart.x);
        view.y = panStart.vy + (e.clientY - panStart.y);
        setTransform();
      } else if (activePtrs.size === 2 && pinchState) {
        const pts = Array.from(activePtrs.values());
        const p0 = svgPointFromClient(pts[0].x, pts[0].y);
        const p1 = svgPointFromClient(pts[1].x, pts[1].y);
        const d1 = dist(p0,p1);

        const k1 = clamp(pinchState.k0 * (d1 / (pinchState.dist0 || 1)), 0.35, 2.6);
        const mid = { x: (p0.x+p1.x)/2, y: (p0.y+p1.y)/2 };
        const k0 = pinchState.k0;

        view.x = mid.x - (mid.x - pinchState.x0) * (k1 / k0);
        view.y = mid.y - (mid.y - pinchState.y0) * (k1 / k0);
        view.k = k1;
        setTransform();
      }
      e.preventDefault();
    }, { passive:false });

    function endPointer(e){
      activePtrs.delete(e.pointerId);
      if (activePtrs.size === 0) { panStart = null; pinchState = null; }
      if (activePtrs.size === 1) {
        const remaining = Array.from(activePtrs.values())[0];
        panStart = { x: remaining.x, y: remaining.y, vx: view.x, vy: view.y };
        pinchState = null;
      }
      e.preventDefault();
    }
    svg.addEventListener("pointerup", endPointer, { passive:false });
    svg.addEventListener("pointercancel", endPointer, { passive:false });

    // Touch fallback (iOS ì•ˆì „ë§)
    let tPan = null, tPinch = null;
    function getTouchMid(t1, t2){
      const rect = svg.getBoundingClientRect();
      return { x: ((t1.clientX+t2.clientX)/2)-rect.left, y: ((t1.clientY+t2.clientY)/2)-rect.top };
    }
    function getTouchDist(t1, t2){
      const rect = svg.getBoundingClientRect();
      const p0 = { x: t1.clientX-rect.left, y: t1.clientY-rect.top };
      const p1 = { x: t2.clientX-rect.left, y: t2.clientY-rect.top };
      return Math.hypot(p0.x-p1.x, p0.y-p1.y);
    }
    svg.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        tPan = { x: t.clientX, y: t.clientY, vx: view.x, vy: view.y };
        tPinch = null;
      } else if (e.touches.length === 2) {
        const d0 = getTouchDist(e.touches[0], e.touches[1]);
        tPinch = { k0: view.k, x0: view.x, y0: view.y, d0 };
        tPan = null;
      }
      e.preventDefault();
    }, { passive:false });

    svg.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1 && tPan) {
        const t = e.touches[0];
        view.x = tPan.vx + (t.clientX - tPan.x);
        view.y = tPan.vy + (t.clientY - tPan.y);
        setTransform();
      } else if (e.touches.length === 2 && tPinch) {
        const d1 = getTouchDist(e.touches[0], e.touches[1]);
        const k1 = clamp(tPinch.k0 * (d1 / (tPinch.d0 || 1)), 0.35, 2.6);

        const mid = getTouchMid(e.touches[0], e.touches[1]);
        const k0 = tPinch.k0;

        view.x = mid.x - (mid.x - tPinch.x0) * (k1 / k0);
        view.y = mid.y - (mid.y - tPinch.y0) * (k1 / k0);
        view.k = k1;
        setTransform();
      }
      e.preventDefault();
    }, { passive:false });

    svg.addEventListener("touchend", (e) => {
      if (e.touches.length === 0) { tPan = null; tPinch = null; }
      if (e.touches.length === 1) {
        const t = e.touches[0];
        tPan = { x: t.clientX, y: t.clientY, vx: view.x, vy: view.y };
        tPinch = null;
      }
    }, { passive:false });

    // -----------------------------
    // init
    // -----------------------------
    function resetView(){
      const rect = svg.getBoundingClientRect();
      view.k = isMobile ? 0.72 : 1;
      view.x = rect.width/2;
      view.y = rect.height/2 + 40;
      setTransform();
    }

    window.addEventListener("resize", () => { resetView(); render(); });

    expandAllBtn.addEventListener("click", expandAll);
    collapseAllBtn.addEventListener("click", collapseAll);
    resetViewBtn.addEventListener("click", () => { resetView(); render(); });

    // ê²€ìƒ‰ input ì´ë²¤íŠ¸ ì œê±°

    resetView();
    render();
  </script>
</body>
</html>
